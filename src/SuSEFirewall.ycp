/**
 * File:	modules/SuSEFirewall.ycp
 * Package:	SuSE firewall configuration
 * Summary:	Main module, providing IO functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *		Michal Svec <msvec@suse.cz>
 *		Michael Hager <mike@suse.de>
 *		Lukas Ocilka <locilka@suse.cz>
 *
 * $Id$
 */

{

module "SuSEFirewall";
textdomain "firewall";

import "Label";
import "Remote";
import "Mode";
import "Popup";
import "Progress";
import "Report";
import "Service";
import "Summary";
import "NetworkDevices";

/* global settings map */
global map<string,any> settings = $[];

global boolean personal_firewall_is_active = false;

/* something in proposal already changed by user */
global boolean proposal_changed_by_user = false;

/* default value for firewall enabled/disabled */
global boolean enable_firewall = true;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

global boolean start = false;

/**
 * Private function for handling the Portmapper support
 *
 * @param boolean	enable or disable the support
 */
define boolean HandlePortmapSupport (boolean enable) {
    list<string> ext_rpc = splitstring(SuSEFirewall::settings["FW_SERVICES_EXT_RPC"]:"", " ");

    // All needed services for Portmapper
    list<string> rpc_services = [
	// NFS support
	"nlockmgr", "status", "nfs", "nfs_acl", "mountd",
	// NIS support
	"ypserv", "fypxfrd", "ypbind", "ypasswdd",
    ];
    if (enable == true) {
	// adding needed rpc services
	ext_rpc = (list<string>) union (ext_rpc, rpc_services);
    } else {
	// removing all rpc services
	foreach ( string remove_this, rpc_services, {
	    ext_rpc = filter (string service, ext_rpc, ``{
		return service != remove_this;
	    });
	});
    }

    SuSEFirewall::settings["FW_SERVICES_EXT_RPC"] = mergestring(ext_rpc, " ");
}

    /* Definition of the TCP and UDP ports needed for services
     *
     * "service_id" : $[
     *    "tcp_ports" : [ "list", "of", "ports" ],
     *    "udp_ports" : [ "list", "of", "ports" ],
     *    "special"   : LocalFunctionForHandlingSpecialNeeds,
     * ]
     */
    global map<string, map<string, any> > firewall_services_definition = $[
	"http" : $[
	    "tcp_ports" : [ "http" ],
	    "udp_ports" : [ ],
	],
	"https" : $[
	    "tcp_ports" : [ "https" ],
	    "udp_ports" : [ ],
	],
	"smtp" : $[
	    "tcp_ports" : [ "smtp" ],
	    "udp_ports" : [ ],
	],
	"pop3" : $[
	    "tcp_ports" : [ "pop3" ],
	    "udp_ports" : [ ],
	],
	"pop3s" : $[
	    "tcp_ports" : [ "pop3s" ],
	    "udp_ports" : [ ],
	],
	"imap" : $[
	    "tcp_ports" : [ "imap" ],
	    "udp_ports" : [ ],
	],
	"imaps" : $[
	    "tcp_ports" : [ "imaps" ],
	    "udp_ports" : [ ],
	],
	"samba-server" : $[
	    "tcp_ports" : [ "netbios-ns", "netbios-dgm", "netbios-ssn", "microsoft-ds" ],
	    "udp_ports" : [ ],
	],
	"ssh" : $[
	    "tcp_ports" : [ "ssh" ],
	    "udp_ports" : [ ],
	],
	"rsync" : $[
	    "tcp_ports" : [ "rsync" ],
	    "udp_ports" : [ ],
	],
	"dhcp-server" : $[
	    "tcp_ports" : [ ],
	    "udp_ports" : [ "bootps" ],
	],
	"dhcp-client" : $[
	    "tcp_ports" : [ ],
	    "udp_ports" : [ "bootpc" ],
	],
	"dns-server" : $[
	    "tcp_ports" : [ "domain" ],
	    "udp_ports" : [ "domain" ],
	],
	"portmap" : $[
	    "tcp_ports" : [ "sunrpc" ],
	    "udp_ports" : [ "sunrpc" ],
	    "special"	: HandlePortmapSupport,
	],
	"nfs-server" : $[
	    "tcp_ports" : [ "nfs" ],
	    "udp_ports" : [ ],
	],
	"vnc" : $[
	    "tcp_ports" : [ "5801", "5901" ],
	    "udp_ports" : [ ],
	],
	"tftp" : $[
	    "tcp_ports" : [ "tftp" ],
	    "udp_ports" : [ ],
	],
	// Internet Printing Protocol as a Server
	"ipp-tcp" : $[
	    "tcp_ports" : [ "ipp" ],
	    "udp_ports" : [ ],
	],
	// Internet Printing Protocol as a Client
	"ipp-udp" : $[
	    "tcp_ports" : [ ],
	    "udp_ports" : [ "ipp" ],
	],
	"tftp" : $[
	    "tcp_ports" : [ "tftp" ],
	    "udp_ports" : [ ],
	],
	"ldap" : $[
	    "tcp_ports" : [ "ldap" ],
	    "udp_ports" : [ ],
	],
	"ldaps" : $[
	    "tcp_ports" : [ "ldaps" ],
	    "udp_ports" : [ ],
	],
    ];


/**
 * Constructor
 */
global define void SuSEFirewall () {

    if (Mode::test) {
	return;
    }

    if (!Mode::config) {

	string REJECT_ALL_INCOMING_CONNECTIONS = (string) SCR::Read(.sysconfig.personal-firewall.REJECT_ALL_INCOMING_CONNECTIONS);
	if( REJECT_ALL_INCOMING_CONNECTIONS == nil ) REJECT_ALL_INCOMING_CONNECTIONS = "";
	if( REJECT_ALL_INCOMING_CONNECTIONS != "" &&  REJECT_ALL_INCOMING_CONNECTIONS != "no")
	{
	    personal_firewall_is_active = true;
	}
	else
	{
	    personal_firewall_is_active = false;
	}
    }
}

/**
 * Get all firewall settings from the first parameter
 * (for use by autoinstallation).
 * @param s data to be imported
 * @return true on success
 */
global define boolean Import(map s) {
    settings = (map<string,any>)s;
    start = settings["start_firewall"]:false;
    return true;
}

/**
 * Dump the firewall settings to a single map
 * (for use by autoinstallation).
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() {
    if(haskey(settings, "network_devices" ))
	settings = remove(settings, "network_devices" );

    settings["start_firewall"] = start;
    return settings;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() {

    string summary = "";
    summary = Summary::AddHeader(summary, _("External Device"));
    summary = Summary::AddLine(summary, (settings["FW_DEV_EXT"]:"" != "") ?
			       settings["FW_DEV_EXT"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("Internal Device"));
    summary = Summary::AddLine(summary, (settings["FW_DEV_INT"]:"" != "") ?
			       settings["FW_DEV_INT"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("Protect from Internal"));
    summary = Summary::AddLine(summary, (settings["FW_PROTECT_FROM_INTERNAL"]:"" != "") ?
			       settings["FW_PROTECT_FROM_INTERNAL"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("External TCP Services"));
    summary = Summary::AddLine(summary, (settings["FW_SERVICES_EXT_TCP"]:"" != "") ?
			       settings["FW_SERVICES_EXT_TCP"]:"" : Summary::NotConfigured());

    summary = Summary::AddLine(summary, _("(Start the configuration to view more options)"));

    return [ summary, [] ];
}

/**
 * Fill the map of all firewall settings from the SCR
 * @return true on success
 */
global define boolean Read() {

    // Check if firewall running
    start = Service::Enabled("SuSEfirewall2_init");

    NetworkDevices::Read ();

    string FW_IPSEC_TRUST = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_IPSEC_TRUST);
    if( FW_IPSEC_TRUST == nil ) FW_IPSEC_TRUST = "no";
    settings["FW_IPSEC_TRUST"] = FW_IPSEC_TRUST;

    string FW_LOG_ACCEPT_ALL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_ALL);
    if( FW_LOG_ACCEPT_ALL == nil ) FW_LOG_ACCEPT_ALL = "no";
    settings["FW_LOG_ACCEPT_ALL"] = FW_LOG_ACCEPT_ALL;

    string FW_LOG_ACCEPT_CRIT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_CRIT);
    if( FW_LOG_ACCEPT_CRIT == nil ) FW_LOG_ACCEPT_CRIT = "yes";
    settings["FW_LOG_ACCEPT_CRIT"] = FW_LOG_ACCEPT_CRIT;

    string FW_LOG_DROP_ALL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_DROP_ALL);
    if( FW_LOG_DROP_ALL == nil ) FW_LOG_DROP_ALL = "no";
    settings["FW_LOG_DROP_ALL"] = FW_LOG_DROP_ALL;

    string FW_LOG_DROP_CRIT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_DROP_CRIT);
    if( FW_LOG_DROP_CRIT == nil ) FW_LOG_DROP_CRIT = "yes";
    settings["FW_LOG_DROP_CRIT"] = FW_LOG_DROP_CRIT;

    string FW_PROTECT_FROM_INTERNAL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_PROTECT_FROM_INTERNAL);
    if( FW_PROTECT_FROM_INTERNAL == nil ) FW_PROTECT_FROM_INTERNAL = "yes";
    settings["FW_PROTECT_FROM_INTERNAL"] = FW_PROTECT_FROM_INTERNAL;

    string FW_DEV_DMZ = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_DMZ);
    if( FW_DEV_DMZ == nil ) FW_DEV_DMZ = "";
    settings["FW_DEV_DMZ"] = FW_DEV_DMZ;

    string FW_DEV_INT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_INT);
    if( FW_DEV_INT == nil ) FW_DEV_INT = "";
    settings["FW_DEV_INT"] = FW_DEV_INT;

    string FW_DEV_EXT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_EXT);
    if( FW_DEV_EXT == nil ) FW_DEV_EXT = "";
    settings["FW_DEV_EXT"] = FW_DEV_EXT;

    string FW_SERVICES_DMZ_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_IP);
    if( FW_SERVICES_DMZ_IP == nil ) FW_SERVICES_DMZ_IP = "";
    settings["FW_SERVICES_DMZ_IP"] = FW_SERVICES_DMZ_IP;

    string FW_SERVICES_EXT_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_IP);
    if( FW_SERVICES_EXT_IP == nil ) FW_SERVICES_EXT_IP = "";
    settings["FW_SERVICES_EXT_IP"] = FW_SERVICES_EXT_IP;

    string FW_SERVICES_INT_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_IP);
    if( FW_SERVICES_INT_IP == nil ) FW_SERVICES_INT_IP = "";
    settings["FW_SERVICES_INT_IP"] = FW_SERVICES_INT_IP;

    string FW_SERVICES_DMZ_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_UDP);
    if( FW_SERVICES_DMZ_UDP == nil ) FW_SERVICES_DMZ_UDP = "";
    settings["FW_SERVICES_DMZ_UDP"] = FW_SERVICES_DMZ_UDP;

    string FW_SERVICES_INT_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_UDP);
    if( FW_SERVICES_INT_UDP == nil ) FW_SERVICES_INT_UDP = "";
    settings["FW_SERVICES_INT_UDP"] = FW_SERVICES_INT_UDP;

    string FW_SERVICES_EXT_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_UDP);
    if( FW_SERVICES_EXT_UDP == nil ) FW_SERVICES_EXT_UDP = "";
    settings["FW_SERVICES_EXT_UDP"] = FW_SERVICES_EXT_UDP;

    string FW_SERVICES_DMZ_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_TCP);
    if( FW_SERVICES_DMZ_TCP == nil ) FW_SERVICES_DMZ_TCP = "";
    settings["FW_SERVICES_DMZ_TCP"] = FW_SERVICES_DMZ_TCP;

    string FW_SERVICES_INT_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_TCP);
    if( FW_SERVICES_INT_TCP == nil ) FW_SERVICES_INT_TCP = "";
    settings["FW_SERVICES_INT_TCP"] = FW_SERVICES_INT_TCP;

    string FW_SERVICES_EXT_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_TCP);
    if( FW_SERVICES_EXT_TCP == nil ) FW_SERVICES_EXT_TCP = "";
    settings["FW_SERVICES_EXT_TCP"] = FW_SERVICES_EXT_TCP;

    string FW_AUTOPROTECT_SERVICES = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_AUTOPROTECT_SERVICES);
    if( FW_AUTOPROTECT_SERVICES == nil ) FW_AUTOPROTECT_SERVICES = "yes";
    settings["FW_AUTOPROTECT_SERVICES"] = FW_AUTOPROTECT_SERVICES;

    string FW_MASQ_NETS = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_MASQ_NETS);
    if( FW_MASQ_NETS == nil ) FW_MASQ_NETS = "";
    settings["FW_MASQ_NETS"] = FW_MASQ_NETS;

    string FW_ROUTE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_ROUTE);
    if( FW_ROUTE == nil ) FW_ROUTE = "no";
    settings["FW_ROUTE"] = FW_ROUTE;

    string FW_MASQUERADE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_MASQUERADE);
    if( FW_MASQUERADE == nil ) FW_MASQUERADE = "no";
    settings["FW_MASQUERADE"] = FW_MASQUERADE;

    string FW_ALLOW_FW_TRACEROUTE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_ALLOW_FW_TRACEROUTE);
    if( FW_ALLOW_FW_TRACEROUTE == nil ) FW_ALLOW_FW_TRACEROUTE = "yes";
    settings["FW_ALLOW_FW_TRACEROUTE"] = FW_ALLOW_FW_TRACEROUTE;

    string FW_SERVICES_EXT_RPC = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_RPC);
    if( FW_SERVICES_EXT_RPC == nil ) FW_SERVICES_EXT_RPC = "";
    settings["FW_SERVICES_EXT_RPC"] = FW_SERVICES_EXT_RPC;

    y2milestone("settings=%1", settings);
    return true;
}

/*
 * Propose Firewall settings
 */
global define void Propose () ``{
    y2milestone("Initializing proposal");
    
    // All network devices
    list<string> netdevices = NetworkDevices::List("");
    netdevices = filter(string dev, netdevices, ``{
	return dev != "" && !issubstring(dev, "lo") && !issubstring(dev, "sit");
    });

    // Firewall is disabled if there is no network
    if (size(netdevices)==0) {
	SuSEFirewall::enable_firewall = false;
	return;
    }
    SuSEFirewall::enable_firewall = true;

    settings["FW_DEV_EXT"] = mergestring(sort(netdevices), " ");
    settings["FW_DEV_INT"] = "";
    settings["FW_DEV_DMZ"] = "";

    // list of Open TCP ports
    list<string> allowed_tcp_ports = [];
    // SSH installation opens SSH in firewall by default
    if (Mode::usessh==true) {
	allowed_tcp_ports = add(allowed_tcp_ports, "ssh");
    }
    // VNC installation or Alowed Remote administration opens VNC in firewall by default
    if ((Mode::vnc==true) || (Remote::allow_administration==true)) {
	allowed_tcp_ports = add(allowed_tcp_ports, "5801 5901");
    }
    // SSH should be open by default [after meeting 2004-07-29]
    allowed_tcp_ports = add(allowed_tcp_ports, "ssh");

    // list of Open UDP ports
    list<string> allowed_udp_ports = [];

    // No services are allowed by default, excepting allowed_tcp_ports for EXT_TCP
    settings["FW_SERVICES_EXT_IP"] = "";
    settings["FW_SERVICES_EXT_TCP"] = mergestring(toset(allowed_tcp_ports), " ");
    settings["FW_SERVICES_EXT_UDP"] = mergestring(toset(allowed_udp_ports), " ");

    settings["FW_SERVICES_INT_IP"] = "";
    settings["FW_SERVICES_INT_TCP"] = "";
    settings["FW_SERVICES_INT_UDP"] = "";
    
    settings["FW_SERVICES_DMZ_IP"] = "";
    settings["FW_SERVICES_DMZ_TCP"] = "";
    settings["FW_SERVICES_DMZ_UDP"] = "";

    // We don't do any masquerade or route by default
    settings["FW_MASQUERADE"] = "no";
    settings["FW_MASQ_NETS"] = "";
    settings["FW_ROUTE"] = "no";

    // ICMP is allowed
    settings["FW_ALLOW_FW_TRACEROUTE"] = "yes";

    // We don't trust any IPsec
    settings["FW_IPSEC_TRUST"] = "no";
    settings["FW_PROTECT_FROM_INTERNAL"] = "yes";

    // All services are auto-protected by default
    settings["FW_AUTOPROTECT_SERVICES"] = "yes";

    // All critical packets are logged
    settings["FW_LOG_ACCEPT_ALL"] = "no";
    settings["FW_LOG_ACCEPT_CRIT"] = "yes";
    settings["FW_LOG_DROP_ALL"] = "no";
    settings["FW_LOG_DROP_CRIT"] = "yes";
}

/**
 * Reset Firewall settings
 */
global define void Reset () ``{
    if (Mode::autoinst)
	return;

    if (! Mode::config)
	Propose();
    else
	Read();
}

/**
 * Returns Preformatted text for proposal
 */
global define string GetPreformattedProposal () {
    string ret = "<ul>";

    // TRANSLATORS: Proposal rich text item, %1 is the firewall status - enabled or disabled
    ret = ret + sformat(_("<li>Firewall is %1</li>"),
	(SuSEFirewall::enable_firewall ?
	    // TRANSLATORS: Proposal rich text item value - Firewall is enabled
	    _("enabled")
	    :
	    // TRANSLATORS: Proposal rich text item value - Firewall is disabled
	    _("disabled")
	)
    );

    if (SuSEFirewall::enable_firewall == true) {
	string open_tcp_ports = settings["FW_SERVICES_EXT_TCP"]:"";
	// This is the hack for presenting unregistered ports of VNC
	if (regexpmatch(open_tcp_ports,"5801 5901")) {
	    open_tcp_ports = regexpsub(open_tcp_ports, "(.*)(5801 5901)(.*)", "\\1VNC\(\\2\)\\3");
	}

	string open_udp_ports = settings["FW_SERVICES_EXT_UDP"]:"";

	// TRANSLATORS: Proposal rich text item, %1 is list of open TCP ports
	ret = ret + sformat(_("<li>Open TCP ports: %1</li>"),
	    (open_tcp_ports != "" ?
		open_tcp_ports
		:
		// TRANSLATORS: Proposal rich text - Opened ports: none
		_("none")
	    )
	// TRANSLATORS: Proposal rich text item, %1 is list of open UDP ports
	) + sformat(_("<li>Open UDP ports: %1</li>"),
	    (open_udp_ports != "" ?
		open_udp_ports
		:
		// TRANSLATORS: Proposal rich text - Opened UDP ports: none
		_("none")
	    )
	);
    }

    ret = ret + "</ul>";

    return ret;
}

/**
 * Update the SCR from the map of all firewall settings
 * @param m a map of all firewall settings
 * @return true on success
 */
global define boolean Write() {

    // only activated firewall's setting is writen in installation (proposal) mode
    if ((Mode::config == false) && (SuSEFirewall::enable_firewall == false)) {
	return true;
    }

    if(!start && !write_only)
	return false;

    Progress::New(
	/* Progress caption */
	_("Firewall configuration -- saving settings"),
	/* Progress contents */
	_("Preparing ..."),
	3,
	[
	    /* Progress stage 1/3 */
	    _("Stop firewall"),
	    /* Progress stage 2/3 */
	    _("Save settings"),
	    /* Progress stage 3/3 */
	    _("Start firewall")
	],
	[
	    /* Progress step 1/3 */
	    _("Stopping firewall..."),
	    /* Progress step 2/3 */
	    _("Saving settings..."),
	    /* Progress step 3/3 */
	    _("Starting firewall...")
	],
	""
    );

    Progress::NextStage();

    boolean retry = true;
    while(retry) {

	retry = false;
	if(Service::RunInitScript("SuSEfirewall2_setup", "stop") != 0) {

	    /* Popup text */
	    string whatfailedmsg = _("Stopping the firewall failed");
	    symbol ret = Popup::AnyQuestion3(whatfailedmsg,
		    "", Label::ContinueButton(), Label::AbortButton(),
		    Label::RetryButton(), `focus_yes );

	    if(ret == `retry) {
		retry = true;
	    }
	    else if(ret == `no) {
		return false;
	    }
	}
    }

    Progress::NextStage();
    boolean write_ret = false;

    string FW_IPSEC_TRUST = settings["FW_IPSEC_TRUST"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_IPSEC_TRUST, FW_IPSEC_TRUST);

    string FW_LOG_ACCEPT_ALL = settings["FW_LOG_ACCEPT_ALL"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_ALL, FW_LOG_ACCEPT_ALL);

    string FW_LOG_ACCEPT_CRIT = settings["FW_LOG_ACCEPT_CRIT"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_CRIT, FW_LOG_ACCEPT_CRIT);

    string FW_LOG_DROP_ALL = settings["FW_LOG_DROP_ALL"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_DROP_ALL, FW_LOG_DROP_ALL);

    string FW_LOG_DROP_CRIT = settings["FW_LOG_DROP_CRIT"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_DROP_CRIT, FW_LOG_DROP_CRIT);

    string FW_PROTECT_FROM_INTERNAL = settings["FW_PROTECT_FROM_INTERNAL"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_PROTECT_FROM_INTERNAL, FW_PROTECT_FROM_INTERNAL);

    string FW_DEV_DMZ = settings["FW_DEV_DMZ"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_DMZ, FW_DEV_DMZ);

    string FW_DEV_INT = settings["FW_DEV_INT"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_INT, FW_DEV_INT);

    string FW_DEV_EXT = settings["FW_DEV_EXT"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_EXT, FW_DEV_EXT);

    string FW_SERVICES_DMZ_IP = settings["FW_SERVICES_DMZ_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_IP, FW_SERVICES_DMZ_IP);

    string FW_SERVICES_EXT_IP = settings["FW_SERVICES_EXT_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_IP, FW_SERVICES_EXT_IP);

    string FW_SERVICES_INT_IP = settings["FW_SERVICES_INT_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_IP, FW_SERVICES_INT_IP);

    string FW_SERVICES_DMZ_UDP = settings["FW_SERVICES_DMZ_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_UDP, FW_SERVICES_DMZ_UDP);

    string FW_SERVICES_INT_UDP = settings["FW_SERVICES_INT_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_UDP, FW_SERVICES_INT_UDP);

    string FW_SERVICES_EXT_UDP = settings["FW_SERVICES_EXT_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_UDP, FW_SERVICES_EXT_UDP);

    string FW_SERVICES_DMZ_TCP = settings["FW_SERVICES_DMZ_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_TCP, FW_SERVICES_DMZ_TCP);

    string FW_SERVICES_INT_TCP = settings["FW_SERVICES_INT_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_TCP, FW_SERVICES_INT_TCP);

    string FW_SERVICES_EXT_TCP = settings["FW_SERVICES_EXT_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_TCP, FW_SERVICES_EXT_TCP);

    string FW_AUTOPROTECT_SERVICES = settings["FW_AUTOPROTECT_SERVICES"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_AUTOPROTECT_SERVICES, FW_AUTOPROTECT_SERVICES);

    string FW_MASQ_NETS = settings["FW_MASQ_NETS"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_MASQ_NETS, FW_MASQ_NETS);

    string FW_ROUTE = settings["FW_ROUTE"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_ROUTE, FW_ROUTE);

    string FW_MASQUERADE = settings["FW_MASQUERADE"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_MASQUERADE, FW_MASQUERADE);

    string FW_ALLOW_FW_TRACEROUTE = settings["FW_ALLOW_FW_TRACEROUTE"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_ALLOW_FW_TRACEROUTE, FW_ALLOW_FW_TRACEROUTE);

    string FW_SERVICES_EXT_RPC = settings["FW_SERVICES_EXT_RPC"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_RPC, FW_SERVICES_EXT_RPC);

    if(personal_firewall_is_active) {
	write_ret = SCR::Write(.sysconfig.personal-firewall.REJECT_ALL_INCOMING_CONNECTIONS,"no");
	write_ret = SCR::Write(.sysconfig.personal-firewall,nil);
    }

    // sync settings to file !!!
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2, nil);
    if (!write_ret)
	/* Popup text */
	Report::Error(_("Writing settings failed"));

    Progress::NextStage();

    y2milestone("Writing firewall settings finished, return code %1", write_ret);

    // Why is this needed?
    if (personal_firewall_is_active)
	SCR::Execute (.target.bash,"/sbin/SuSEpersonal-firewall",$[]);

    list<string> services = [
	"SuSEfirewall2_init",
	"SuSEfirewall2_setup",
	"SuSEfirewall2_final",
    ];

    foreach(string service, services, {

	y2milestone("Enabling service %1", service);
	if(!Service::Enable(service))
	    /* Popup text */
	    Report::Error(_("Starting the firewall failed"));

    });

    Progress::NextStage();

    if(!write_only)
	Service::RunInitScript("SuSEfirewall2_final", "start");

    Progress::Finish();

    return true;
}

/**
 * Is this interface external for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is an external interface
 */
global define boolean IsExtInterface( string interface ) {
    list servs = splitstring(settings[ "FW_DEV_EXT" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 * Is this interface internal for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is an internal interface
 */
global define boolean IsIntInterface( string interface ) {
    list servs = splitstring(settings[ "FW_DEV_INT" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 * Is this interface DMZ for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is a DMZ interface
 */
global define boolean IsDmzInterface( string interface ) {
    list servs = splitstring(settings[ "FW_DEV_DMZ" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 * In which group of interfaces is the interface presented.
 * Returns nil if the interface is not presented anywhere.
 *
 * @param string interface		the name of the interface
 * @return string interface_group	"INT", "DMZ", "EXT", nil
 */
global define string GetInterfaceGroup ( string interface ) {
    list interface_group = [];
    foreach ( string group, (list<string>) [ "INT", "DMZ", "EXT" ], {
	if (group == "INT") {
	    if (IsIntInterface(interface)) interface_group = add (interface_group, group);
	} else if (group == "DMZ") {
	    if (IsDmzInterface(interface)) interface_group = add (interface_group, group);
	} else if (group == "EXT") {
	    if (IsExtInterface(interface)) interface_group = add (interface_group, group);
	}
    });

    if (size(interface_group)>1) {
	// Error message, %1 = interface name (eth0)
	Report::Error(sformat(_("Interface %1 is presented in more groups of interfaces.\n
Continuing with configuration can produce errors.\n
Please, leave the configuration and repair it manually in\n
file '/etc/sysconfig/SuSEfirewall2'."), interface));
    }

    // return the first existence of interface in groups
    // if it is not presented, nil is returned
    string ret = nil;
    if (size(interface_group)>0) {
	ret = interface_group[0]:"";
    }

    return ret;
}

/**
 * Which interfaces are in interface_group
 *
 * @param string interface_group	the name of the group "INT", "DMZ", "EXT"
 * @return list<string> interface	the list of inetrfaces in interface_group
 */
global define list<string> GetInterfacesInGroup ( string interface_group ) {
    list<string> ret = [];
    if (interface_group == "INT") {
	ret = (list<string>) splitstring(settings[ "FW_DEV_INT" ]:"", " ");
    } else if (interface_group == "DMZ") {
	ret = (list<string>) splitstring(settings[ "FW_DEV_DMZ" ]:"", " ");
    } else if (interface_group == "EXT") {
	ret = (list<string>) splitstring(settings[ "FW_DEV_EXT" ]:"", " ");
    } else {
	ret = nil;
	y2error("Unknow interface group '%1', known are only 'INT', 'DMZ', 'EXT'");
    }
    return ret;
}

/**
 * In which group is the interface
 *
 * @param string	interface
 * @return string	group
 */ 
global define string GetGroupOfInterface ( string interface ) {
    if (IsIntInterface(interface)) {
	return "INT";
    } else if (IsDmzInterface(interface)) {
	return "DMZ";
    } else if (IsExtInterface(interface)) {
	return "EXT";
    } else {
	return nil;
    }
}

/**
 * In which groups are the interfaces
 * @param list<string>	interfaces
 * @param list<string>	groups
 */
global define list<string> GetGroupsOfInterfaces ( list<string> interfaces ) {
    list<string> ret = [];
    foreach (string interface, interfaces, {
	string group = GetGroupOfInterface(interface);
	if (group != nil) ret = add(ret, group);
    });

    return toset(ret);
}

/**
 *  Add service into a given setting variable. Low-level manipulation.
 *
 *  @param set		the name of the sysconfig variable to be modified
 *  @param service	the name of the service
 *  @return boolean	true on success
 */
define boolean AddServiceToConfig( string set, string service ) {

    y2debug( "Before adding services: %1" , settings[set]:"");

    list<string> servs = splitstring(settings[set]:"", " ");
    if(servs == nil) servs = [];

    if(contains(servs, service))
    {
	y2warning("service %1 already allowed in %2", service, set);
	return true;
    }

    servs = add(servs, service);
    string sers = mergestring(servs, " ");
    if(servs == nil) return false;
    settings[ set ] = sers;

    y2debug( "After adding services: %1" , settings[set]:"");

    return true;
}

/**
 *  Remove service from a given setting variable. Low-level manipulation.
 *
 *  @param set		the name of the sysconfig variable to be modified
 *  @param service	the name of the service
 *  @return boolean	true on success
 */
define boolean RemoveServiceFromConfig( string set, string service ) {
    list<string> servs = splitstring(settings[set]:"", " ");
    if(servs == nil) servs = [];

    servs = filter(string s, servs, {
	return service != s;
    });
    string sers = mergestring(servs, " ");
    if(servs == nil) return false;
    settings[ set ] = sers;

    return true;
}

/**
 *  Add service for a given interface and protocol into a firewall. Will not
 *  modify the list of configured interfaces in the firewall.
 *
 *  @param service	the name of the service
 *  @param proto	UDP, TCP or IP
 *  @param interface	the name of the interface, for example eth0, "all" for
 *  all interfaces, INT, EXT or DMZ for the respective zone
 *  @return boolean	true on success
 */
global define boolean AddService(string service, string proto, string interface) {

    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2debug( "Unknown protocol: %1", proto );
	return false;
    }

    if( interface == "all" ) {
	y2debug( "Adding to all %1", service );
	AddServiceToConfig ( "FW_SERVICES_EXT_"+proto, service );
	AddServiceToConfig ( "FW_SERVICES_INT_"+proto, service );
	AddServiceToConfig ( "FW_SERVICES_DMZ_"+proto, service );
	y2debug( "FW_SERVICES_EXT: ", settings["FW_SERVICES_EXT_TCP"]:nil );
    } else {
	// find out where is the interface
	if(interface == "EXT" || IsExtInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_EXT_"+proto, service );
	}
	else if( interface == "INT" || IsIntInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_INT_"+proto, service );
	}
	else if( interface == "DMZ" || IsDmzInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_DMZ_"+proto, service );
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    return true;
}

/**
 *  Remove service for a given interface and protocol from a firewall. Will not
 *  modify the list of configured interfaces in the firewall.
 *
 *  @param service	the name of the service
 *  @param proto	UDP, TCP or IP
 *  @param interface	the name of the interface, for example eth0, "all" for
 *  all interfaces, INT, EXT or DMZ for the respective zone
 *  @return boolean	true on success
 */
global define boolean RemoveService(string service, string proto, string interface) {

    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2error( "Unknown protocol: %1", proto );
	return false;
    }

    if( interface == "all" ) {
	y2debug( "Removing from all %1", service );
	RemoveServiceFromConfig ( "FW_SERVICES_EXT_"+proto, service );
	RemoveServiceFromConfig ( "FW_SERVICES_INT_"+proto, service );
	RemoveServiceFromConfig ( "FW_SERVICES_DMZ_"+proto, service );
	y2debug( "FW_SERVICES_EXT: ", settings["FW_SERVICES_EXT_TCP"]:nil );
    } else {
	// find out where is the interface
	if( interface == "EXT" || IsExtInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_EXT_"+proto, service );
	}
	else if( interface == "INT" || IsIntInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_INT_"+proto, service );
	}
	else if( interface == "DMZ" || IsDmzInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_DMZ_"+proto, service );
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    return true;
}

/**
 *  Whether a service is allowed on the specified interface
 *
 *  @param proto	UDP, TCP or IP
 *  @param name		Service name, e.g. "isakmp"
 *  @param interface	the name of the interface, for example eth0, "any" for
 *  any interface, INT, EXT or DMZ for the respective zone
 *  @return boolean	true if service is allowed
 */
global define boolean HaveService(string service, string proto, string interface)
{
    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2error( "Unknown protocol: %1", proto );
	return false;
    }

    string servstr = "";

    if( interface == "any" )
    {
	servstr = settings["FW_SERVICES_EXT_"+proto]:""
	    + settings["FW_SERVICES_INT_"+proto]:""
	    + settings["FW_SERVICES_DMZ_"+proto]:"";
    } else
    {
	// find out where is the interface
	if(interface == "EXT" || IsExtInterface( interface )) {
	    servstr = settings["FW_SERVICES_EXT_"+proto]:"";
	}
	else if( interface == "INT" || IsIntInterface( interface )) {
	    servstr = settings["FW_SERVICES_INT_"+proto]:"";
	}
	else if( interface == "DMZ" || IsDmzInterface( interface )) {
	    servstr = settings["FW_SERVICES_DMZ_"+proto]:"";
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    list<string> servs = splitstring(servstr, " ");
    if(servs == nil) servs = [];
    return contains(servs, service);
}

/**
  * Get the interface with the smallest security
  * @param interfaces list of interfaces
  * @return string in SuSEfirewall syntax - no, yes, dmz, ext
  */
global define string MostInsecureInterface (list<string> interfaces) {
    string result = "no";
    foreach (string iface, interfaces, {
        if (IsExtInterface (iface))
            result = "ext";
        else if (IsDmzInterface (iface) && result != "ext")
            result = "dmz";
        else if (IsIntInterface (iface) && result != "ext" && result != "dmz")
            result = "yes";
    });
    return result;
}

/**
 * whether IPsec traffic is allowed and treated as internal
 * @returns true if it is allowed, false if not and nil if unknown
 * */
global define boolean IsIPsecAllowed()
{
    boolean isakmpallowed	= SuSEFirewall::HaveService("isakmp", "UDP", "EXT")
					    || SuSEFirewall::HaveService("500", "UDP", "EXT");

    boolean espallowed		= SuSEFirewall::HaveService("esp", "IP", "INT")
					    || SuSEFirewall::HaveService("50", "IP", "INT");

    string FW_IPSEC_TRUST	= SuSEFirewall::settings["FW_IPSEC_TRUST"]:"no";
    if( (FW_IPSEC_TRUST == "yes" || FW_IPSEC_TRUST == "int") && isakmpallowed && espallowed)
	return true;
    else if( FW_IPSEC_TRUST == "no" && !isakmpallowed && !espallowed)
	return false;
    else
	return nil;
}

/**
 * Allow or Disallow IPsec Traffic and treat it as internal
 * @param yes true, false or nil for no change
 * */
global define void AllowIPsec(boolean yes)
{
    if ( yes == nil ) return;

    if( yes == true )
    {
	SuSEFirewall::AddService("isakmp", "UDP", "EXT");
	SuSEFirewall::AddService("esp", "IP", "INT");
	settings["FW_IPSEC_TRUST"] = "int";
    }
    else if( yes == false )
    {
	SuSEFirewall::RemoveService("isakmp", "UDP", "EXT");
	SuSEFirewall::RemoveService("esp", "IP", "INT");
	settings["FW_IPSEC_TRUST"] = "no";
    }
}

/**
 * Function for handling needed support for services in SuSEfirewall2
 * For example: "portmap" fills some strings in FW_SERVICES_EXT_RPC
 * 
 * @param string	service to change it's state
 * @param boolean	new service state
 * @return boolean	true is successful
 */
global define boolean RunServiceSupport (string service_id, boolean new_service_state) {
    boolean(boolean) function = (boolean(boolean)) firewall_services_definition[service_id,"special"]:nil;
    if (function == nil) {
	return true;
    }
    y2milestone("Setting special service support for '%1' to '%2'", service_id, new_service_state);
    return function(new_service_state);
}

/**
 * Function for Opening or Closing ports for device_groups
 *
 * @param string	name or number of port
 * @param string	protocol (TCP|UDP)
 * @param string	device group (INT|DMZ|EXT)
 * @param boolean	true to open, false to close
 */
global define boolean SetPortForGroup (string port_name, string protocol, string device_group, boolean new_state) {
    if (device_group != "INT" && device_group != "DMZ" && device_group != "EXT") {
	y2error("Not allowed device group '%1'", device_group);
	return false;
    }
    if (protocol != "TCP" && protocol != "UDP") {
	y2error("Not allowed protocol '%1'", protocol);
	return false;
    }

    string setting_ident = (string) ("FW_SERVICES_" + device_group + "_" + protocol);

    // enabling support
    if (new_state == true) {
	settings[setting_ident] =
	    mergestring(
		toset(
		    splitstring((settings[setting_ident]:"" + " " + port_name), " ")
		), " "
	    );
    // disabling support
    } else {
	settings[setting_ident] =
	    mergestring(
		(filter ( string service_in_fw, (
		    toset( splitstring( settings[setting_ident]:"", " " ) )
		    ), ``{
			return service_in_fw != port_name;
		    }
		)), " "
	    );
    }
}

/**
 * Function for enabling or disabling more services in more device groups at once
 *
 * @param list<string>	list of services [ "dhcp-server" | "ssh" | "vnc"... ]
 * @param list<string>	list of device groups [ "INT" | "DMZ" | "EXT" ]
 * @param boolean	true = enable, false = disable
 * @return boolean	if successful
 */
global define boolean SetServicesForGroups (list<string> services_id, list<string> device_groups, boolean new_status) {
    list<string> allowed_device_groups = ["INT", "EXT", "DMZ"];

    // no groups == all groups
    if (size(device_groups)==0) device_groups = allowed_device_groups;

    // setting for each service
    foreach (string service_id, services_id, {

	list<string> service_tcp_ports = (list<string>) firewall_services_definition[service_id,"tcp_ports"]:[];
	list<string> service_udp_ports = (list<string>) firewall_services_definition[service_id,"udp_ports"]:[];

	// controling if service is defined
	if ((size(service_tcp_ports)==0) && (size(service_udp_ports)==0)) {
	    y2error("Service '%1' has no TCP or UDP ports defined for Firewall support", service_id);
	    continue;
	}

	// setting in all device groups
	foreach (string device_group, device_groups, {
	    // current device group is not allowed
	    if (contains(allowed_device_groups, device_group) == false) {
		y2error("Device group '%1' is not allowed, allowed are %2", device_group, allowed_device_groups);
		continue;
	    }

	    // setting all TCP ports
	    foreach (string tcp_port, service_tcp_ports, ``{
		SetPortForGroup(tcp_port, "TCP", device_group, new_status);
	    });
	    // setting all UDP ports
	    foreach (string udp_port, service_udp_ports, ``{
		SetPortForGroup(udp_port, "UDP", device_group, new_status);
	    });
	});
    });

    return true;
}

/**
 * Function for enabling or disabling more services in more devices at once
 *
 * @param list<string>	list of services [ "dhcp-server" | "ssh" | "vnc" ... ]
 * @param list<string>	list of device groups [ "eth0" | "ppp0" | "eth4"... ]
 * @param boolean	true = enable, false = disable
 * @return boolean	if successful
 */
global define boolean SetServices (list<string> services_id, list<string> devices, boolean new_status) {
    list<string> groups_of_interfaces = GetGroupsOfInterfaces(devices);
    if (size(groups_of_interfaces)==0) {
	y2error("Devices %1 are not in any group if interfaces", devices);
	return false;
    }

    return SetServicesForGroups (services_id, groups_of_interfaces, new_status);
}

/**
 * Function for getting information if service is enabled in firewall in device group
 *
 * @param string	service for testing ( "dhcp-server" | "ssh" | "vnc" ... )
 * @param string	device group ( "INT", "DMZ", "EXT" )
 * @return boolean	true is supported, false is unsupported
 */
global define boolean IsServiceSupportedInGroup (string service, string group) {
    list<string> device_groups = [ "INT", "DMZ", "EXT" ];
    if (contains(device_groups, group) == false) {
	y2error("Unknown group '%1'", group);
	return nil;
    }

    list<string> tcp_ports_needed = (list<string>) firewall_services_definition[service, "tcp_ports"]:[];
    list<string> udp_ports_needed = (list<string>) firewall_services_definition[service, "udp_ports"]:[];
    if ((size(tcp_ports_needed)==0) && (size(udp_ports_needed)==0)) {
	y2error("Service '%1' is not defined", service);
	return nil;
    }

    boolean supported = true;

    foreach(string tcp_port, tcp_ports_needed, {
	if (HaveService(tcp_port, "TCP", group)==false) {
	    supported = false;
	    break;
	}
    });
    foreach(string udp_port, udp_ports_needed, {
	if (HaveService(udp_port, "UDP", group)==false) {
	    supported = false;
	    break;
	}
    });

    return supported;
}

/**
 * Function return map of support status for services in all device groups
 *
 * @param list<string>	list of services [ "dhcp-server" | "ssh" | "vnc" ... ]
 * @return map<string, map<string, boolean> >	map<service, map<device_group, status> >
 */
global define map<string, map<string, boolean> > GetServicesInGroups (list<string> services) {
    map<string, map<string, boolean> > ret = $[ ];
    list<string> device_groups = [ "INT", "DMZ", "EXT" ];

    foreach (string service_id, services, {
	ret[service_id] = $[];
	foreach (string device_group, device_groups, {
	    ret[service_id,device_group] = (IsServiceSupportedInGroup (service_id, device_group));
	});
    });

    return ret;
}

/**
 * Function return list of network devices used by firewall
 * (Mentioned in FW_DEV_INT, FW_DEV_DMZ or FW_DEV_EXT)
 *
 * @return list<string>	list of devices
 */
global list<string> GetFirewallDevices () {
    if (Mode::installation==false) {
	NetworkDevices::Read();
    }

    list<string> netdevices = NetworkDevices::List("");
    netdevices = filter(string dev, netdevices, ``{
	return dev != "" && !issubstring(dev, "lo") && !issubstring(dev, "sit") && GetGroupOfInterface(dev)!=nil;
    });

    return netdevices;
}

/**
 * Function return map of support status for services in all network device
 * used by firewall
 *
 * @param list<string>	list of services [ "dhcp-server" | "ssh" | "vnc" ... ]
 * @return map<string, map<string, boolean> >	map<service, map<network_device, status> >
 */
global define map<string, map<string, boolean> > GetServices (list<string> services) {
    map<string, map<string, boolean> > ret = $[ ];
    map<string, map<string, boolean> > supported_in_groups = GetServicesInGroups(services);
    list<string> network_devices = GetFirewallDevices();

    map<string, string> device_to_group = $[ ];
    foreach (string network_device, network_devices, {
	device_to_group[network_device] = GetGroupOfInterface(network_device);
    });

    foreach (string service, services, {
	ret[service] = $[ ];
	foreach (string device, network_devices, {
	    string device_is_in_group = device_to_group[device]:nil;
	    ret[service,device] = supported_in_groups[service,device_is_in_group]:nil;
	});
    });

    return ret;
}

/* EOF */
}
