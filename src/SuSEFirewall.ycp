/**
 * File:	modules/SuSEFirewall.ycp
 * Package:	SuSE firewall configuration
 * Summary:	Main module, providing IO functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *		Michal Svec <msvec@suse.cz>
 *		Michael Hager <mike@suse.de>
 *
 * $Id$
 */

{

module "SuSEFirewall";
textdomain "firewall";

import "Label";
import "Mode";
import "Popup";
import "Progress";
import "Report";
import "Service";
import "Summary";

/* global settings map */
global map<string,any> settings = $[];

global boolean personal_firewall_is_active = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

global boolean start = false;

/**
 * Constructor
 */
global define void SuSEFirewall () ``{

    if (!Mode::config) {

	string REJECT_ALL_INCOMING_CONNECTIONS = (string) SCR::Read(.sysconfig.personal-firewall.REJECT_ALL_INCOMING_CONNECTIONS);
	if( REJECT_ALL_INCOMING_CONNECTIONS == nil ) REJECT_ALL_INCOMING_CONNECTIONS = "";
	if( REJECT_ALL_INCOMING_CONNECTIONS != "" &&  REJECT_ALL_INCOMING_CONNECTIONS != "no")
	{
	    personal_firewall_is_active = true;
	}
	else
	{
	    personal_firewall_is_active = false;
	}
    }
}

/**
 * Get all firewall settings from the first parameter
 * (for use by autoinstallation).
 * @param s data to be imported
 * @return true on success
 */
global define boolean Import(map s) ``{
    settings = (map<string,any>)s;
    start = settings["start_firewall"]:false;
    return true;
}

/**
 * Dump the firewall settings to a single map
 * (for use by autoinstallation).
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() ``{
    if(haskey(settings, "network_devices" ))
	settings = remove(settings, "network_devices" );

    settings["start_firewall"] = start;
    return settings;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{

    string summary = "";
    summary = Summary::AddHeader(summary, _("External Device"));
    summary = Summary::AddLine(summary, (settings["FW_DEV_EXT"]:"" != "") ?
			       settings["FW_DEV_EXT"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("Internal Device"));
    summary = Summary::AddLine(summary, (settings["FW_DEV_INT"]:"" != "") ?
			       settings["FW_DEV_INT"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("Protect from Internal"));
    summary = Summary::AddLine(summary, (settings["FW_PROTECT_FROM_INTERNAL"]:"" != "") ?
			       settings["FW_PROTECT_FROM_INTERNAL"]:"" : Summary::NotConfigured());

    summary = Summary::AddHeader(summary, _("External TCP Services"));
    summary = Summary::AddLine(summary, (settings["FW_SERVICES_EXT_TCP"]:"" != "") ?
			       settings["FW_SERVICES_EXT_TCP"]:"" : Summary::NotConfigured());

    summary = Summary::AddLine(summary, _("(Start the configuration to view more options)"));

    return [ summary, [] ];
}

/**
 * Fill the map of all firewall settings from the SCR
 * @return true on success
 */
global define boolean Read() ``{

    // Check if firewall running
    start = Service::Enabled("SuSEfirewall2_init");

//  DO NOT EDIT THIS CODE!, modify 'liste' instead!
//  <AUTOCODE READ>
    string FW_IPSEC_TRUST = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_IPSEC_TRUST);
    if( FW_IPSEC_TRUST == nil ) FW_IPSEC_TRUST = "no";
    settings["FW_IPSEC_TRUST"] = FW_IPSEC_TRUST;

    string FW_LOG_ACCEPT_ALL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_ALL);
    if( FW_LOG_ACCEPT_ALL == nil ) FW_LOG_ACCEPT_ALL = "no";
    settings["FW_LOG_ACCEPT_ALL"] = FW_LOG_ACCEPT_ALL;

    string FW_LOG_ACCEPT_CRIT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_CRIT);
    if( FW_LOG_ACCEPT_CRIT == nil ) FW_LOG_ACCEPT_CRIT = "yes";
    settings["FW_LOG_ACCEPT_CRIT"] = FW_LOG_ACCEPT_CRIT;

    string FW_LOG_DROP_ALL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_DROP_ALL);
    if( FW_LOG_DROP_ALL == nil ) FW_LOG_DROP_ALL = "no";
    settings["FW_LOG_DROP_ALL"] = FW_LOG_DROP_ALL;

    string FW_LOG_DROP_CRIT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_LOG_DROP_CRIT);
    if( FW_LOG_DROP_CRIT == nil ) FW_LOG_DROP_CRIT = "yes";
    settings["FW_LOG_DROP_CRIT"] = FW_LOG_DROP_CRIT;

    string FW_PROTECT_FROM_INTERNAL = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_PROTECT_FROM_INTERNAL);
    if( FW_PROTECT_FROM_INTERNAL == nil ) FW_PROTECT_FROM_INTERNAL = "yes";
    settings["FW_PROTECT_FROM_INTERNAL"] = FW_PROTECT_FROM_INTERNAL;

    string FW_DEV_DMZ = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_DMZ);
    if( FW_DEV_DMZ == nil ) FW_DEV_DMZ = "";
    settings["FW_DEV_DMZ"] = FW_DEV_DMZ;

    string FW_DEV_INT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_INT);
    if( FW_DEV_INT == nil ) FW_DEV_INT = "";
    settings["FW_DEV_INT"] = FW_DEV_INT;

    string FW_DEV_EXT = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_DEV_EXT);
    if( FW_DEV_EXT == nil ) FW_DEV_EXT = "";
    settings["FW_DEV_EXT"] = FW_DEV_EXT;

    string FW_SERVICES_DMZ_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_IP);
    if( FW_SERVICES_DMZ_IP == nil ) FW_SERVICES_DMZ_IP = "";
    settings["FW_SERVICES_DMZ_IP"] = FW_SERVICES_DMZ_IP;

    string FW_SERVICES_EXT_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_IP);
    if( FW_SERVICES_EXT_IP == nil ) FW_SERVICES_EXT_IP = "";
    settings["FW_SERVICES_EXT_IP"] = FW_SERVICES_EXT_IP;

    string FW_SERVICES_INT_IP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_IP);
    if( FW_SERVICES_INT_IP == nil ) FW_SERVICES_INT_IP = "";
    settings["FW_SERVICES_INT_IP"] = FW_SERVICES_INT_IP;

    string FW_SERVICES_DMZ_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_UDP);
    if( FW_SERVICES_DMZ_UDP == nil ) FW_SERVICES_DMZ_UDP = "";
    settings["FW_SERVICES_DMZ_UDP"] = FW_SERVICES_DMZ_UDP;

    string FW_SERVICES_INT_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_UDP);
    if( FW_SERVICES_INT_UDP == nil ) FW_SERVICES_INT_UDP = "";
    settings["FW_SERVICES_INT_UDP"] = FW_SERVICES_INT_UDP;

    string FW_SERVICES_EXT_UDP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_UDP);
    if( FW_SERVICES_EXT_UDP == nil ) FW_SERVICES_EXT_UDP = "";
    settings["FW_SERVICES_EXT_UDP"] = FW_SERVICES_EXT_UDP;

    string FW_SERVICES_DMZ_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_TCP);
    if( FW_SERVICES_DMZ_TCP == nil ) FW_SERVICES_DMZ_TCP = "";
    settings["FW_SERVICES_DMZ_TCP"] = FW_SERVICES_DMZ_TCP;

    string FW_SERVICES_INT_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_TCP);
    if( FW_SERVICES_INT_TCP == nil ) FW_SERVICES_INT_TCP = "";
    settings["FW_SERVICES_INT_TCP"] = FW_SERVICES_INT_TCP;

    string FW_SERVICES_EXT_TCP = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_TCP);
    if( FW_SERVICES_EXT_TCP == nil ) FW_SERVICES_EXT_TCP = "";
    settings["FW_SERVICES_EXT_TCP"] = FW_SERVICES_EXT_TCP;

    string FW_AUTOPROTECT_SERVICES = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_AUTOPROTECT_SERVICES);
    if( FW_AUTOPROTECT_SERVICES == nil ) FW_AUTOPROTECT_SERVICES = "yes";
    settings["FW_AUTOPROTECT_SERVICES"] = FW_AUTOPROTECT_SERVICES;

    string FW_MASQ_NETS = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_MASQ_NETS);
    if( FW_MASQ_NETS == nil ) FW_MASQ_NETS = "";
    settings["FW_MASQ_NETS"] = FW_MASQ_NETS;

    string FW_ROUTE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_ROUTE);
    if( FW_ROUTE == nil ) FW_ROUTE = "no";
    settings["FW_ROUTE"] = FW_ROUTE;

    string FW_MASQUERADE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_MASQUERADE);
    if( FW_MASQUERADE == nil ) FW_MASQUERADE = "no";
    settings["FW_MASQUERADE"] = FW_MASQUERADE;

    string FW_ALLOW_FW_TRACEROUTE = (string) SCR::Read(.sysconfig.SuSEfirewall2.FW_ALLOW_FW_TRACEROUTE);
    if( FW_ALLOW_FW_TRACEROUTE == nil ) FW_ALLOW_FW_TRACEROUTE = "yes";
    settings["FW_ALLOW_FW_TRACEROUTE"] = FW_ALLOW_FW_TRACEROUTE;

//  </AUTOCODE>

    // fetch list of network devices
    list<map> devicelist = (list<map>) SCR::Read(.probe.netif);
    if (devicelist == nil) devicelist = [];

    // filter the device names
    list devices = [];
    foreach(map device, devicelist, ``{
	string dev = device["dev_name"]:"";
	if(dev != "" && !issubstring(dev, "lo") && !issubstring(dev, "sit")) {
            devices[size(devices)] = dev;
	}
    });

    settings["network_devices"] = devices;

    return true;
}


/**
 * Update the SCR from the map of all firewall settings
 * @param m a map of all firewall settings
 * @return true on success
 */
global define boolean Write() ``{

    if(!start && !write_only)
	return false;

    Progress::New(
	/* Progress caption */
	_("Firewall configuration -- saving settings"),
	/* Progress contents */
	_("Preparing ..."),
	3,
	[
	    /* Progress stage 1/3 */
	    _("Stop firewall"),
	    /* Progress stage 2/3 */
	    _("Save settings"),
	    /* Progress stage 3/3 */
	    _("Start firewall")
	],
	[
	    /* Progress step 1/3 */
	    _("Stopping firewall..."),
	    /* Progress step 2/3 */
	    _("Saving settings..."),
	    /* Progress step 3/3 */
	    _("Starting firewall...")
	],
	""
    );

    Progress::NextStage();

    boolean retry = true;
    while(retry) {

	retry = false;
	if(Service::RunInitScript("SuSEfirewall2_setup", "stop") != 0) {

	    /* Popup text */
	    string whatfailedmsg = _("Stopping the firewall failed");
	    symbol ret = Popup::AnyQuestion3(whatfailedmsg,
		    "", Label::ContinueButton(), Label::AbortButton(),
		    Label::RetryButton(), `focus_yes );

	    if(ret == `retry) {
		retry = true;
	    }
	    else if(ret == `no) {
		return false;
	    }
	}
    }

    Progress::NextStage();
    boolean write_ret = false;

//  DO NOT EDIT THIS CODE!, modify 'liste' instead!
//  <AUTOCODE WRITE>
    string FW_IPSEC_TRUST = settings["FW_IPSEC_TRUST"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_IPSEC_TRUST, FW_IPSEC_TRUST);

    string FW_LOG_ACCEPT_ALL = settings["FW_LOG_ACCEPT_ALL"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_ALL, FW_LOG_ACCEPT_ALL);

    string FW_LOG_ACCEPT_CRIT = settings["FW_LOG_ACCEPT_CRIT"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_ACCEPT_CRIT, FW_LOG_ACCEPT_CRIT);

    string FW_LOG_DROP_ALL = settings["FW_LOG_DROP_ALL"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_DROP_ALL, FW_LOG_DROP_ALL);

    string FW_LOG_DROP_CRIT = settings["FW_LOG_DROP_CRIT"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_LOG_DROP_CRIT, FW_LOG_DROP_CRIT);

    string FW_PROTECT_FROM_INTERNAL = settings["FW_PROTECT_FROM_INTERNAL"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_PROTECT_FROM_INTERNAL, FW_PROTECT_FROM_INTERNAL);

    string FW_DEV_DMZ = settings["FW_DEV_DMZ"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_DMZ, FW_DEV_DMZ);

    string FW_DEV_INT = settings["FW_DEV_INT"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_INT, FW_DEV_INT);

    string FW_DEV_EXT = settings["FW_DEV_EXT"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_DEV_EXT, FW_DEV_EXT);

    string FW_SERVICES_DMZ_IP = settings["FW_SERVICES_DMZ_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_IP, FW_SERVICES_DMZ_IP);

    string FW_SERVICES_EXT_IP = settings["FW_SERVICES_EXT_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_IP, FW_SERVICES_EXT_IP);

    string FW_SERVICES_INT_IP = settings["FW_SERVICES_INT_IP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_IP, FW_SERVICES_INT_IP);

    string FW_SERVICES_DMZ_UDP = settings["FW_SERVICES_DMZ_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_UDP, FW_SERVICES_DMZ_UDP);

    string FW_SERVICES_INT_UDP = settings["FW_SERVICES_INT_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_UDP, FW_SERVICES_INT_UDP);

    string FW_SERVICES_EXT_UDP = settings["FW_SERVICES_EXT_UDP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_UDP, FW_SERVICES_EXT_UDP);

    string FW_SERVICES_DMZ_TCP = settings["FW_SERVICES_DMZ_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_DMZ_TCP, FW_SERVICES_DMZ_TCP);

    string FW_SERVICES_INT_TCP = settings["FW_SERVICES_INT_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_INT_TCP, FW_SERVICES_INT_TCP);

    string FW_SERVICES_EXT_TCP = settings["FW_SERVICES_EXT_TCP"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_SERVICES_EXT_TCP, FW_SERVICES_EXT_TCP);

    string FW_AUTOPROTECT_SERVICES = settings["FW_AUTOPROTECT_SERVICES"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_AUTOPROTECT_SERVICES, FW_AUTOPROTECT_SERVICES);

    string FW_MASQ_NETS = settings["FW_MASQ_NETS"]:"";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_MASQ_NETS, FW_MASQ_NETS);

    string FW_ROUTE = settings["FW_ROUTE"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_ROUTE, FW_ROUTE);

    string FW_MASQUERADE = settings["FW_MASQUERADE"]:"no";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_MASQUERADE, FW_MASQUERADE);

    string FW_ALLOW_FW_TRACEROUTE = settings["FW_ALLOW_FW_TRACEROUTE"]:"yes";
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2.FW_ALLOW_FW_TRACEROUTE, FW_ALLOW_FW_TRACEROUTE);

//  </AUTOCODE>

    if(personal_firewall_is_active) {
	write_ret = SCR::Write(.sysconfig.personal-firewall.REJECT_ALL_INCOMING_CONNECTIONS,"no");
	write_ret = SCR::Write(.sysconfig.personal-firewall,nil);
    }

    // sync settings to file !!!
    write_ret = SCR::Write(.sysconfig.SuSEfirewall2, nil);
    if (!write_ret)
	/* Popup text */
	Report::Error(_("Writing settings failed"));

    Progress::NextStage();

    y2milestone("Writing firewall settings finished, return code %1", write_ret);

    // Why is this needed?
    if (personal_firewall_is_active)
	SCR::Execute (.target.bash,"/sbin/SuSEpersonal-firewall",$[]);

    list<string> services = [
	"SuSEfirewall2_init",
	"SuSEfirewall2_setup",
	"SuSEfirewall2_final",
    ];

    foreach(string service, services, ``{

	y2milestone("Enabling service %1", service);
	if(!Service::Enable(service))
	    /* Popup text */
	    Report::Error(_("Starting the firewall failed"));

    });

    Progress::NextStage();

    if(!write_only)
	Service::RunInitScript("SuSEfirewall2_final", "start");

    Progress::Finish();

    return true;
}

/**
 * Is this interface external for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is an external interface
 */
global define boolean IsExtInterface( string interface ) ``{
    list servs = splitstring(settings[ "FW_DEV_EXT" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 * Is this interface internal for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is an internal interface
 */
global define boolean IsIntInterface( string interface ) ``{
    list servs = splitstring(settings[ "FW_DEV_INT" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 * Is this interface DMZ for firewall?
 *
 * @param interface	the name of the interface
 * @return boolean	true if it is a DMZ interface
 */
global define boolean IsDmzInterface( string interface ) ``{
    list servs = splitstring(settings[ "FW_DEV_DMZ" ]:"", " ");
    if(servs == nil) servs = [];
    return contains( servs, interface );
}

/**
 *  Add service into a given setting variable. Low-level manipulation.
 *
 *  @param set		the name of the sysconfig variable to be modified
 *  @param service	the name of the service
 *  @return boolean	true on success
 */
define boolean AddServiceToConfig( string set, string service ) ``{

    y2debug( "Before adding services: %1" , settings[set]:"");

    list<string> servs = splitstring(settings[set]:"", " ");
    if(servs == nil) servs = [];

    if(contains(servs, service))
    {
	y2warning("service %1 already allowed in %2", service, set);
	return true;
    }

    servs = add(servs, service);
    string sers = mergestring(servs, " ");
    if(servs == nil) return false;
    settings[ set ] = sers;

    y2debug( "After adding services: %1" , settings[set]:"");

    return true;
}

/**
 *  Remove service from a given setting variable. Low-level manipulation.
 *
 *  @param set		the name of the sysconfig variable to be modified
 *  @param service	the name of the service
 *  @return boolean	true on success
 */
define boolean RemoveServiceFromConfig( string set, string service ) ``{
    list<string> servs = splitstring(settings[set]:"", " ");
    if(servs == nil) servs = [];

    servs = filter(string s, servs, ``(service != s) );
    string sers = mergestring(servs, " ");
    if(servs == nil) return false;
    settings[ set ] = sers;

    return true;
}

/**
 *  Add service for a given interface and protocol into a firewall. Will not
 *  modify the list of configured interfaces in the firewall.
 *
 *  @param service	the name of the service
 *  @param proto	UDP, TCP or IP
 *  @param interface	the name of the interface, for example eth0, "all" for
 *  all interfaces, INT, EXT or DMZ for the respective zone
 *  @return boolean	true on success
 */
global define boolean AddService(string service, string proto, string interface) ``{

    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2debug( "Unknown protocol: %1", proto );
	return false;
    }

    if( interface == "all" ) {
	y2debug( "Adding to all %1", service );
	AddServiceToConfig ( "FW_SERVICES_EXT_"+proto, service );
	AddServiceToConfig ( "FW_SERVICES_INT_"+proto, service );
	AddServiceToConfig ( "FW_SERVICES_DMZ_"+proto, service );
	y2debug( "FW_SERVICES_EXT: ", settings["FW_SERVICES_EXT_TCP"]:nil );
    } else {
	// find out where is the interface
	if(interface == "EXT" || IsExtInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_EXT_"+proto, service );
	}
	else if( interface == "INT" || IsIntInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_INT_"+proto, service );
	}
	else if( interface == "DMZ" || IsDmzInterface( interface )) {
	    AddServiceToConfig ( "FW_SERVICES_DMZ_"+proto, service );
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    return true;
}

/**
 *  Remove service for a given interface and protocol from a firewall. Will not
 *  modify the list of configured interfaces in the firewall.
 *
 *  @param service	the name of the service
 *  @param proto	UDP, TCP or IP
 *  @param interface	the name of the interface, for example eth0, "all" for
 *  all interfaces, INT, EXT or DMZ for the respective zone
 *  @return boolean	true on success
 */
global define boolean RemoveService(string service, string proto, string interface) ``{

    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2error( "Unknown protocol: %1", proto );
	return false;
    }

    if( interface == "all" ) {
	y2debug( "Removing from all %1", service );
	RemoveServiceFromConfig ( "FW_SERVICES_EXT_"+proto, service );
	RemoveServiceFromConfig ( "FW_SERVICES_INT_"+proto, service );
	RemoveServiceFromConfig ( "FW_SERVICES_DMZ_"+proto, service );
	y2debug( "FW_SERVICES_EXT: ", settings["FW_SERVICES_EXT_TCP"]:nil );
    } else {
	// find out where is the interface
	if( interface == "EXT" || IsExtInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_EXT_"+proto, service );
	}
	else if( interface == "INT" || IsIntInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_INT_"+proto, service );
	}
	else if( interface == "DMZ" || IsDmzInterface( interface ) ) {
	    RemoveServiceFromConfig ( "FW_SERVICES_DMZ_"+proto, service );
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    return true;
}

/**
 *  Whether a service is allowed on the specified interface
 *
 *  @param proto	UDP, TCP or IP
 *  @param name		Service name, e.g. "isakmp"
 *  @param interface	the name of the interface, for example eth0, "any" for
 *  any interface, INT, EXT or DMZ for the respective zone
 *  @return boolean	true if service is allowed
 */
global define boolean HaveService(string service, string proto, string interface)
{
    if( proto != "UDP" && proto != "TCP" && proto != "IP" ) {
	y2error( "Unknown protocol: %1", proto );
	return false;
    }

    string servstr = "";

    if( interface == "any" )
    {
	servstr = settings["FW_SERVICES_EXT_"+proto]:""
	    + settings["FW_SERVICES_INT_"+proto]:""
	    + settings["FW_SERVICES_DMZ_"+proto]:"";
    } else
    {
	// find out where is the interface
	if(interface == "EXT" || IsExtInterface( interface )) {
	    servstr = settings["FW_SERVICES_EXT_"+proto]:"";
	}
	else if( interface == "INT" || IsIntInterface( interface )) {
	    servstr = settings["FW_SERVICES_INT_"+proto]:"";
	}
	else if( interface == "DMZ" || IsDmzInterface( interface )) {
	    servstr = settings["FW_SERVICES_DMZ_"+proto]:"";
	}
	else
	{
	    y2warning( "Interface %1 is not configured for firewall", interface );
	    return false;
	}
    }

    list<string> servs = splitstring(servstr, " ");
    if(servs == nil) servs = [];
    return contains(servs, service);
}

/**
  * Get the interface with the smallest security
  * @param interfaces list of interfaces
  * @return string in SuSEfirewall syntax - no, yes, dmz, ext
  */
global define string MostInsecureInterface (list<string> interfaces) ``{
    string result = "no";
    foreach (string iface, interfaces, ``{
        if (IsExtInterface (iface))
            result = "ext";
        else if (IsDmzInterface (iface) && result != "ext")
            result = "dmz";
        else if (IsIntInterface (iface) && result != "ext" && result != "dmz")
            result = "yes";
    });
    return result;
}

/**
 * whether IPsec traffic is allowed and treated as internal
 * @returns true if it is allowed, false if not and nil if unknown
 * */
global define boolean IsIPsecAllowed()
{
    boolean isakmpallowed	= SuSEFirewall::HaveService("isakmp", "UDP", "EXT")
					    || SuSEFirewall::HaveService("500", "UDP", "EXT");

    boolean espallowed		= SuSEFirewall::HaveService("esp", "IP", "INT")
					    || SuSEFirewall::HaveService("50", "IP", "INT");

    string FW_IPSEC_TRUST	= SuSEFirewall::settings["FW_IPSEC_TRUST"]:"no";
    if( (FW_IPSEC_TRUST == "yes" || FW_IPSEC_TRUST == "int") && isakmpallowed && espallowed)
	return true;
    else if( FW_IPSEC_TRUST == "no" && !isakmpallowed && !espallowed)
	return false;
    else
	return nil;
}

/**
 * Allow or Disallow IPsec Traffic and treat it as internal
 * @param yes true, false or nil for no change
 * */
global define void AllowIPsec(boolean yes)
{
    if ( yes == nil ) return;

    if( yes == true )
    {
	SuSEFirewall::AddService("isakmp", "UDP", "EXT");
	SuSEFirewall::AddService("esp", "IP", "INT");
	settings["FW_IPSEC_TRUST"] = "int";
    }
    else if( yes == false )
    {
	SuSEFirewall::RemoveService("isakmp", "UDP", "EXT");
	SuSEFirewall::RemoveService("esp", "IP", "INT");
	settings["FW_IPSEC_TRUST"] = "no";
    }
}

/* EOF */
}
